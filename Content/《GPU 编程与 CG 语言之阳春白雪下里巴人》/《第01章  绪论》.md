## 第一章  绪论

> 面纱掩盖了过去、现在和将来，历史学家的使命是发现它现在是什么，而不是过去是什么。------ [Henry David Thoreau]
                                         
### 1.1 Programmable Graphics Processing Unit 发展历程
<br>
&#x2003;Programmable Graphics Processing Unit(GPU)，即可编程图形处理单元，通常也称只为可编程图形硬件。
<br>
<br>
&#x2003;GPU 概念在 20 世纪 70 年代末和 80 年代初被提出，使用单片集成电路（monolithic）作为图形芯片，此时的 GPU 已经被用于视频游戏和动画方面，它能够很快地进行几张图片的合成（仅限于此）。在 20 世纪 80 年代末到 90 年代初这段时间内，基于数字信号处理芯片（digital signal process chip）的GPU被研发出来，与前一代相比速度更快、功能更强，当然价格是非常的昂贵。在 1991 年，S3 Graphics公司研制出第一个单芯片 2D 加速器，到了 1995 年，主流的 PC 图形芯片厂商都在自己的芯片上增加了对 2D 加速器的支持。于此同时，固定功能的视图加速器（fixed-function Windows accelerators）由于其高昂的价格而慢慢推出 PC 市场。
<br>
<br>
&#x2003;1998 年 NVIDA 公司宣布 modern GPU 研发成功，标志这 GPU 研发的历史性突破成为现实。通常将 20 世纪 70 年代末到 1998 年的这一段时间称之为pre-GPU 时期，而自 1998 年往后的 GPU 称之为 modern GPU。在 pre-GPU 时期，一些图形厂商，如 SGI、Evans & Sutherland，都研发了各自的 GPU，这些 GPU 在现在并没有被淘汰，依然在持续改进和被广泛的使用，当然价格也是非常的高昂。
<br>
<br>
&#x2003;modern GPU 使用晶体管（transistors）进行计算，在微芯片（microchip）中，GPU 所使用的晶体管已经远远超过 CPU，例如，Intel 在 2.4GHz 的 Pentium IV 上使用5 千 5 百万（55 million）个晶体管；而 NVIDIA 在 GeForce FX GPU 上使用超过 1 亿 2 千 5 百万（125 million）个晶体管，在 NVIDDIA 7800 GXT 上的晶体管达到 3 亿 2 百万（302 million）个。
<br>
<br>
&#x2003;回顾 Modern GPU 的发展历史，自 1998 年后可以分为 4 个阶段。NVIDIA 于 1998 年宣布 Modern GPU 研发成功，这标志第一代 Modern GPU 的诞生，第一代 Modern GPU 包括 NVIDIA TNT2，ATI 的 Rage 和 3Dfx 的 Voodoo3。这些 GPU 可以独立于 CPU 进行像素缓存区的更新，并可以光栅化三角面片以及进行纹理操作，但是缺乏三纬顶点的空间坐标变换能力，这意味着“必须依赖于 GPU 执行顶点坐标变换的计算”。这一时期的 GPU 功能非常有限，只能用于纹理组合的数学计算或者像素颜色值的计算。
<br>
<br>
&#x2003;从 1999 到 2000 年，是第二代 modern GPU 的发展时期。这一时期的 GPU 可以进行三纬坐标转换和光照计算（3D Object Transformation and Lighting T&L），并且 OpenGL 和 DirectX7 都提供了开发接口，支持应用程序使用基于硬件的坐标变换。这是一个非常重要的时期，在此之前只有高级工作站（workstation）的图形硬件才支持快速的顶点变换。同时，这一阶段的 GPU 对于纹理的操作也扩展到了立方体纹理（cube map）。NVIDIA 的 GeForce256，GeForceMAX，ATI 的 Radeon7500 等都是在这一阶段研发的。
<br>
<br>
&#x2003;2001 年是第三代 modern GPU 的发展时期，这一时期研发的 GPU 提供vertex programmability （顶点编程能力），如GeForce 4Ti，ATI 的 8500 等。这些 GPU 允许应用程序制定一个序列的指令进行顶点操作控制（GPU 编程的本质！），这同样是一个具有开创意义的时期，这一时期确立的 GPU 编程思想一直延续到 2009 年的今天，不但深入到工程领域帮助改善人类日常生活（医疗、地质勘探、游戏、电影等），而且开创或延伸了计算机科学的诸多研究领域（体绘制、光照模型、人群动画、通用计算等）。同时，Direct8 和 OpenGL 都本着与时俱进的精神，提供了支持 vertex programmability 的扩展。不过，这一时期的 GPU 还不支持像素级的编程能力，即 fragment programmability （片段编程能力），在第四代 modern GPU 时期，我们将迎来同时支持 vertex programmability 和 fragment programmability 的 GPU。
<br>
<br>
&#x2003;第四代 mondern GPU 的发展时期从 2002 年末到 2003 年。NVIDIA 的 GeForce FX 和 ATI Radeon9700 同时在市场的舞台上闪亮登场，这两种 GPU 都支持 vertex programmablility 和 fragment programmability。同时 DirectX 和 OpenGL 也扩展了自身的 API，用以支持 vertex programmablility 和 fragment programmability。自 2003 年起，可编程图形硬件正式诞生，并且由于 DirectX 和 OpenGL 契而不舍的追赶潮流，导致基于图形硬件的编程技术，简称 GPU 编程，也宣告诞生。恭喜 GeForce 和 ATI 的硬件研发人员，你们终于可以歇口气了，不用较着劲的出显卡了，同时也恭喜 DirectX 和 OpenGL 的研发人员，你们也可以休息下了，不用斗鸡一般的工作了，最后恭喜广大工作在图形图像领域的程序员，你们可以继续学而不倦。
<br><br>
&#x2003;目前最新的可编程图形硬件已经具备了如下功能：
<br>
<br>
&#x2003;1. 支持 vertex programmablility 和 fragment programmability；
<br>
&#x2003;2. 支持 IEEE32 位浮点数运算；
<br>
&#x2003;3. 支持 4 元向量，4 阶矩阵计算；
<br>
&#x2003;4. 提供分之指令，支持循环控制语句；
<br>
&#x2003;5. 具有高带宽的内存传输能力（>27.1GB/s）；
<br>
&#x2003;6. 支持 1D、2D、3D 纹理像素查询和使用，且速度极快；
<br>
&#x2003;7. 支持绘制到纹理功能（Render to Texture，RTT）；
<br>
<br>
&#x2003;关于 GPU 发展历史的相关数据参考了Feng Liu 的“Platform Independent Real-time X3D Shaders and Their Applications in Bioinformatics Visualization”一文
<br>
### 1.2 GPU VS CPU
<br>
&#x2003;从上节阐述了 GPU 的发展历史，那么为什么在 CPU 之外要发展 GPU？GPU 的 vertex programmability 和 fragment programmability 究竟在何处有着怎样的优势？引用在文献【2】第6页的一段话为：<br>
&#x2003;Modern GPUs implement a number of graphics primitive operations in a way that make running them much faster than drawing directly to the screen with the host CPU. They are efficient at manipulating and displaying computer graphics, and their highly parallel structure makes them more effective than typical CPUs for a range of complex algorithms.
&#x2003;这段话的意思是，由于 GPU 具有高并行结构（highly parallel stucture），所以 GPU 在处理图形数据和复杂算法方面拥有比 CPU 更高的效率。图 1 GPU VS CPU 展示了 GPU 和 CPU 在结构上的差异，CPU 大部分面积为控制器和寄存器，与之相比，GPU 拥有更多的 ALU （Arithmetic Logic Unit，逻辑运算单元）用于数据处理，而非数据高速缓存和流控制，这样的结构适合对密集型数据进行并行处理。CPU 执行计算任务时，一个时刻处理一个数据，不存在真正意义上的并行（请回忆 OS 教程上的时间片轮转算法），而 GPU 具有多个处理核，在一个时刻可以并行处理多个数据。<br>